#!/usr/bin/env python
#
# Copyright (C) 2014 Colin Walters <walters@verbum.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import sys
import os
import subprocess
import argparse
sys.path.insert(0,'/usr/share/yum-cli')

import yum
from yum.misc import setup_locale
from yum.packages import parsePackages
from yum.Errors import RepoError
from yum.i18n import exception2msg
from utils import YumUtilBase

from urlparse import urljoin
from urlgrabber.progress import TextMeter
import shutil

import rpmUtils
import logging

from gi.repository import GLib, Gio
from gi.repository import GSystem, OSTree

PKGCACHE_DIR = '/var/cache/atomic'

def fatal(msg):
    sys.stderr.write('error: ' + msg + '\n')
    sys.exit(1)

def run_sync(args, **kwargs):
    """Wraps subprocess.check_call(), logging the command line too."""
    print "Running: %s" % (subprocess.list2cmdline(args), )
    subprocess.check_call(args, **kwargs)

class YumDownloader(YumUtilBase):
    NAME = 'yumdownloader'
    VERSION = '1.0'
    USAGE = '"yumdownloader [options] package1 [package2] [package..]'
    
    def __init__(self):
        YumUtilBase.__init__(self,
                             YumDownloader.NAME,
                             YumDownloader.VERSION,
                             YumDownloader.USAGE)
        self.logger = logging.getLogger("yum.verbose.cli.yumdownloader")  
        
        self.localPackages = []

        # make yumdownloader work as non root user.
        if not self.setCacheDir():
            self.logger.error("Error: Could not make cachedir, exiting")
            sys.exit(50)
            
        # Setup yum (Ts, RPM db, Repo & Sack)
        self.doUtilYumSetup([])
        
    def downloadPackages(self, packages, destdir):
        
        toDownload = []
    
        for pkg in packages:
            toActOn = []

            if not pkg or pkg[0] != '@':
                pkgnames = [pkg]
            else:
                group_string = pkg[1:]
                pkgnames = set()
                for grp in self.comps.return_groups(group_string):
                    if 'mandatory' in self.conf.group_package_types:
                        pkgnames.update(grp.mandatory_packages)
                    if 'default' in self.conf.group_package_types:
                        pkgnames.update(grp.default_packages)
                    if 'optional' in self.conf.group_package_types:
                        pkgnames.update(grp.optional_packages)
                    if self.conf.enable_group_conditionals:
                        for condreq, cond in grp.conditional_packages.iteritems():
                            if self.isPackageInstalled(cond):
                                pkgnames.add(condreq)

                if not pkgnames:
                    self.logger.error('No packages for group %s' % group_string)
                    continue

            pos = self.pkgSack.returnPackages(patterns=pkgnames)
            exactmatch, matched, unmatched = parsePackages(pos, pkgnames)
            installable = (exactmatch + matched)
            if not installable:
                try:
                    installable = self.returnPackagesByDep(pkg)
                    installable = yum.misc.unique(installable)
                except yum.Errors.YumBaseError, msg:
                    self.logger.error(exception2msg(msg))
                    continue

            if not installable: # doing one at a time, apart from groups
                self.logger.error('No Match for argument %s' % pkg)
                continue
            for newpkg in installable:
                toActOn.append(newpkg)
            if toActOn:
                pkgGroups = self._groupPackages(toActOn)
                for group in pkgGroups:
                    pkgs = pkgGroups[group]
                    toDownload.extend(self.bestPackagesFromList(pkgs))
                            
        # If the user supplies to --resolve flag, resolve dependencies for
        # all packages
        # note this might require root access because the headers need to be
        # downloaded into the cachedir (is there a way around this)
        if True:
            self.doTsSetup()
            # Act as if we were to install the packages in toDownload
            for po in toDownload:
                self.tsInfo.addInstall(po)
                self.localPackages.append(po)
            # Resolve dependencies
            self.resolveDeps()
            # Add newly added packages to the toDownload list
            for pkg in self.tsInfo.getMembers():
                if pkg.ts_state in ('i', 'u') and pkg.po not in toDownload:
                    toDownload.append(pkg.po)
        if len(toDownload) == 0:
            self.logger.error('Nothing to download')
            sys.exit(1)

        # set localpaths
        for pkg in toDownload:
            rpmfn = os.path.basename(pkg.remote_path)
            pkg.localpath = os.path.join(destdir, rpmfn)
            pkg.repo.copy_local = True
            pkg.repo.cache = 0

        # use downloader from YumBase
        exit_code = 0
        probs = self.downloadPkgs(toDownload)
        if probs:
            exit_code = 2
            for key in probs:
                for error in probs[key]:
                    self.logger.error('%s: %s', key, error)
        return exit_code
                    
    def _groupPackages(self,pkglist):
        pkgGroups = {}
        for po in pkglist:
            na = '%s.%s' % (po.name,po.arch)
            if not na in pkgGroups:
                pkgGroups[na] = [po]
            else:
                pkgGroups[na].append(po)
        return pkgGroups
            
    # sligly modified from the one in YumUtilBase    
    def doUtilYumSetup(self,opts):
        """do a default setup for all the normal/necessary yum components,
           really just a shorthand for testing"""
        try:
            self._getRepos(doSetup = True)
            archlist = rpmUtils.arch.getArchList()
            self._getSacks(archlist=archlist)
        except yum.Errors.YumBaseError, msg:
            self.logger.critical(exception2msg(msg))
            sys.exit(1)

def run_posts(root):
    run_sync(['ldconfig', '-r', root])

def keyfile_lookup_value(keyfile, section, key, default=None):
    try:
        return keyfile.get_value(section, key)
    except GLib.KeyFileError, e:
        return default

if __name__ == '__main__':
    setup_locale()

    parser = argparse.ArgumentParser(description='Hybrid of rpm-ostree + yum')
    parser.add_argument('--sysroot', type=str, required=True, help='Path to config file')

    sysroot = OSTree.Sysroot.new_default()
    sysroot.load(None)
    _,repo = sysroot.get_repo(None)

    current_deployment = sysroot.get_booted_deployment()
    if current_deployment is None:
        fatal("Not in a booted OSTree deployment")
    current_deployment_root = sysroot.get_deployment_directory(current_deployment)
    originpath = sysroot.get_deployment_origin_path(current_deployment_root)

    origin = GLib.KeyFile.new()
    origin.load_from_file(originpath.get_path(), 0)

    base_refspec = keyfile_lookup_value(origin, 'origin', 'refspec')
    if base_refspec is not None:
        layered_packages = set()
        print "Converting from refspec: " + base_refspec
    else:
        base_refspec = keyfile_lookup_value(origin, 'origin', 'base_refspec')
        if base_refspec is not None:
            layered_packages = set(origin.get_string_list('origin', 'packages'))
            print "Using base refspec: " + base_refspec
        else:
            fatal("Unknown origin specification")

    _,ostree_remote,ostree_ref = OSTree.parse_refspec(base_refspec)
    if ostree_remote is None:
        fatal("Current origin has no OSTree remote")

    _,currentrev = repo.resolve_rev(base_refspec, False)

    GSystem.file_ensure_directory(Gio.File.new_for_path(PKGCACHE_DIR), True, None)

    util = YumDownloader()
    
    cmd = sys.argv[1]
    args = sys.argv[2:]
    upgrade_tree = False
    if cmd == 'upgrade':
        upgrade_tree = True
    elif cmd == 'add':
        layered_packages.update(set(args))
    elif cmd == 'remove':
        for arg in args:
            try:
                layered_packages.remove(arg)
            except KeyError, e:
                fatal("Package '%s' is not in set of layered packages" % (arg, ))
    else:
        fatal("Unknown command '%s'" % (cmd, ))

    if upgrade_tree:
        print "Checking for new tree content"
        repo.pull(ostree_remote, [ostree_ref], 0, None, None)
        _,newrev = repo.resolve_rev(base_refspec, False)
        if currentrev == newrev:
            print "Tree is unchanged at %s" % (newrev, )
        else:
            print "%s is now %s" % (base_refspec, newrev, )
    else:
        newrev = currentrev

    for child in os.listdir(PKGCACHE_DIR):
        childpath = os.path.join(PKGCACHE_DIR, child)
        GSystem.shutil_rm_rf(Gio.File.new_for_path(childpath), None)
    print "Downloading: %s" % (' '.join(layered_packages, ))
    util.downloadPackages(layered_packages, PKGCACHE_DIR)
    print "Package downloads complete"

    new_origin = GLib.KeyFile.new()
    # Need g_key_file_copy
    new_origin.load_from_file(originpath.get_path(), 0)
    new_origin.remove_key('origin', 'refspec')
    new_origin.set_value('origin', 'base_refspec', base_refspec)
    new_origin.set_string_list('origin', 'packages', sorted(list(layered_packages)))

    print "Deploying base tree"
    _,new_deployment = sysroot.deploy_tree(current_deployment.get_osname(),
                                           newrev,
                                           new_origin,
                                           current_deployment, None, None)

    newroot = sysroot.get_deployment_directory(new_deployment)
    print "Tree root prepared: %s" % (newroot.get_path(), )

    # The rpmdb will be hardlinked, but we're about to mutate it below.
    # un-hardlink so that we don't corrupt the object store.
    print "De-hardlinking new RPM database"
    new_rpmdb_path = os.path.join(newroot.get_path(), 'usr/share/rpm')
    for child in os.listdir(new_rpmdb_path):
        srcpath = Gio.File.new_for_path(os.path.join(new_rpmdb_path, child))
        tmppath = Gio.File.new_for_path(os.path.join(new_rpmdb_path, child + '.tmp'))
        srcpath.copy(tmppath, Gio.FileCopyFlags.ALL_METADATA, None, None, None)
        GSystem.file_rename(tmppath, srcpath, None)

    print "Adding packages"
    rpm_argv = ['rpm', '--install', '--root', newroot.get_path(),
                '--dbpath', '/usr/share/rpm',
                '--noscripts', '--notriggers',
                '--nosignature',
                '--oldpackage', '--ignoresize'] 
    rpm_argv.extend([os.path.join(PKGCACHE_DIR, x) for x in os.listdir(PKGCACHE_DIR)])

    run_sync(rpm_argv)
    print "Packages installed in new root"

    run_posts(newroot.get_path())    

    print "Deploying"

    sysroot.simple_write_deployment(new_deployment.get_osname(),
                                    new_deployment, current_deployment, 0, None)

    print "Use \"systemctl reboot\" for the changes to take effect"

